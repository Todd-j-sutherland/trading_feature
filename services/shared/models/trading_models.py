"""Trading-related data models for service communication"""

from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, validator


class TradingAction(str, Enum):
    """Trading action types"""
    STRONG_BUY = "STRONG_BUY"
    BUY = "BUY"
    HOLD = "HOLD"
    SELL = "SELL"
    STRONG_SELL = "STRONG_SELL"


class MarketTrend(str, Enum):
    """Market trend types"""
    BEARISH = "BEARISH"
    NEUTRAL = "NEUTRAL"
    BULLISH = "BULLISH"


class TradingSignal(BaseModel):
    """Trading signal generated by the system"""
    symbol: str = Field(..., description="Stock symbol (e.g., CBA.AX)")
    action: TradingAction = Field(..., description="Recommended trading action")
    confidence: float = Field(..., ge=0.0, description="Confidence score 0-1 or 0-100")
    
    # Price predictions
    current_price: Optional[float] = Field(None, description="Current stock price")
    target_price: Optional[float] = Field(None, description="Target price")
    price_change_pct: Optional[float] = Field(None, description="Expected price change %")
    
    # Market context
    market_context: Optional[MarketTrend] = Field(None, description="Current market trend")
    buy_threshold_used: Optional[float] = Field(None, description="Buy threshold applied")
    
    # Analysis details
    sentiment_score: Optional[float] = Field(None, ge=-1.0, le=1.0, description="Sentiment score -1 to +1")
    technical_score: Optional[float] = Field(None, description="Technical analysis score")
    volume_trend: Optional[float] = Field(None, description="Volume trend indicator")
    
    # Metadata
    timestamp: datetime = Field(default_factory=datetime.now, description="Signal generation time")
    model_version: Optional[str] = Field(None, description="ML model version used")
    features_used: Optional[int] = Field(None, description="Number of features analyzed")
    
    # Reasoning
    reasoning: List[str] = Field(default=[], description="List of factors influencing the signal")
    risk_factors: List[str] = Field(default=[], description="Identified risk factors")
    
    # Trading execution details (added for service compatibility)
    entry_price: Optional[float] = Field(None, description="Entry price for position")
    stop_loss: Optional[float] = Field(None, description="Stop loss price")
    profit_target: Optional[float] = Field(None, description="Profit target price")
    position_size: Optional[float] = Field(None, description="Position size in dollars")
    shares: Optional[int] = Field(None, description="Number of shares")

    @validator('confidence')
    def validate_confidence(cls, v):
        # Convert percentage to decimal if needed (backwards compatibility)
        if v > 1.0:
            v = v / 100.0
        if v < 0.0 or v > 1.0:
            raise ValueError('Confidence must be between 0.0 and 1.0')
        return v
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for backwards compatibility"""
        return self.model_dump()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """Create from dictionary for backwards compatibility"""
        return cls(**data)


class TradingRequest(BaseModel):
    """Request for trading analysis"""
    symbol: str = Field(..., description="Stock symbol to analyze")
    include_sentiment: bool = Field(True, description="Include sentiment analysis")
    include_technical: bool = Field(True, description="Include technical analysis")
    include_market_context: bool = Field(True, description="Include market context")
    
    # Optional overrides
    force_refresh_data: bool = Field(False, description="Force refresh of cached data")
    custom_threshold: Optional[float] = Field(None, description="Custom confidence threshold")
    
    # Metadata
    request_id: Optional[str] = Field(None, description="Unique request identifier")
    user_id: Optional[str] = Field(None, description="User making the request")


class RiskMetrics(BaseModel):
    """Risk assessment metrics"""
    var_95: float = Field(default=0.0, description="Value at Risk 95%")
    portfolio_beta: float = Field(default=1.0, description="Portfolio beta")
    sharpe_ratio: float = Field(default=0.0, description="Sharpe ratio")
    max_drawdown: float = Field(default=0.0, description="Maximum drawdown")
    risk_score: float = Field(default=0.0, description="Overall risk score")


class PositionData(BaseModel):
    """Current position information"""
    symbol: str = Field(..., description="Stock symbol")
    shares: int = Field(..., description="Number of shares held")
    entry_price: float = Field(..., description="Entry price per share")
    current_price: Optional[float] = Field(None, description="Current market price")
    
    # Position management
    stop_loss: Optional[float] = Field(None, description="Stop loss price")
    profit_target: Optional[float] = Field(None, description="Profit target price")
    position_size: float = Field(..., description="Total position value")
    
    # Performance metrics
    unrealized_pnl: Optional[float] = Field(None, description="Unrealized P&L")
    realized_pnl: Optional[float] = Field(None, description="Realized P&L")
    return_pct: Optional[float] = Field(None, description="Return percentage")
    
    # Timestamps
    entry_time: datetime = Field(..., description="Position entry time")
    last_updated: datetime = Field(default_factory=datetime.now, description="Last update time")
    
    # Status
    status: str = Field(default="OPEN", description="Position status (OPEN/CLOSED)")
    exit_reason: Optional[str] = Field(None, description="Reason for exit if closed")


class RiskMetrics(BaseModel):
    """Risk assessment metrics"""
    max_risk_per_trade: float = Field(0.15, description="Maximum risk per trade (15%)")
    max_account_risk: float = Field(0.30, description="Maximum account risk (30%)")
    position_size_limit: float = Field(15000, description="Maximum position size ($)")
    
    # Current risk levels
    current_account_risk: Optional[float] = Field(None, description="Current account risk level")
    available_funds: Optional[float] = Field(None, description="Available trading funds")
    
    # Risk validation
    risk_approved: bool = Field(True, description="Risk validation passed")
    risk_warnings: List[str] = Field(default=[], description="Risk warnings")


class PortfolioSummary(BaseModel):
    """Portfolio summary data"""
    total_value: float = Field(default=0.0, description="Total portfolio value")
    available_cash: float = Field(default=0.0, description="Available cash")
    invested_amount: float = Field(default=0.0, description="Total invested amount")
    
    # Performance
    total_pnl: float = Field(default=0.0, description="Total P&L")
    total_return_pct: float = Field(default=0.0, description="Total return percentage")
    
    # Positions - make these optional with defaults
    active_positions: int = Field(default=0, description="Number of active positions")
    total_positions: int = Field(default=0, description="Total positions")
    positions: List['PositionData'] = Field(default=[], description="List of positions")
    
    # Additional fields that services create
    unrealized_pnl: float = Field(default=0.0, description="Unrealized P&L")
    realized_pnl: float = Field(default=0.0, description="Realized P&L")
    daily_pnl: float = Field(default=0.0, description="Daily P&L")
    portfolio_risk: float = Field(default=0.0, description="Portfolio risk percentage")
    
    # Risk metrics - make optional
    risk_metrics: Optional['RiskMetrics'] = Field(None, description="Current risk assessment")
    
    # Timestamps
    last_updated: datetime = Field(default_factory=datetime.now, description="Last update time")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for backwards compatibility"""
        if hasattr(self, 'model_dump'):
            data = self.model_dump()
        else:
            data = self.__dict__.copy()
        
        # Convert datetime objects to ISO format strings
        for key, value in data.items():
            if hasattr(value, 'isoformat'):  # datetime object
                data[key] = value.isoformat()
        
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PortfolioSummary':
        """Create from dictionary for backwards compatibility"""
        return cls(**data)


class RiskValidationRequest(BaseModel):
    """Request for risk validation"""
    signal: TradingSignal = Field(..., description="Trading signal to validate")
    portfolio_context: Optional[PortfolioSummary] = Field(None, description="Current portfolio state")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for backwards compatibility"""
        return self.model_dump()


# Add Position class that services expect
class Position(BaseModel):
    """Trading position model expected by services"""
    position_id: str = Field(..., description="Unique position identifier")
    symbol: str = Field(..., description="Stock symbol")
    action: str = Field(..., description="Trading action (BUY/SELL)")
    shares: int = Field(..., gt=0, description="Number of shares")
    
    # Pricing
    entry_price: float = Field(..., gt=0, description="Entry price per share")
    current_price: Optional[float] = Field(None, description="Current market price")
    stop_loss: Optional[float] = Field(None, description="Stop loss price")
    profit_target: Optional[float] = Field(None, description="Profit target price")
    
    # Status and timing
    status: str = Field(default="PENDING", description="Position status")
    entry_timestamp: datetime = Field(default_factory=datetime.now, description="Position entry time")
    exit_timestamp: Optional[datetime] = Field(None, description="Position exit time")
    
    # P&L calculations
    unrealized_pnl: Optional[float] = Field(None, description="Unrealized profit/loss")
    realized_pnl: Optional[float] = Field(None, description="Realized profit/loss")
    
    # Metadata
    confidence: Optional[float] = Field(None, description="Confidence in the position")
    
    @property
    def current_value(self) -> Optional[float]:
        """Calculate current position value"""
        if self.current_price:
            return self.current_price * self.shares
        return None
    
    @property
    def entry_value(self) -> float:
        """Calculate entry position value"""
        return self.entry_price * self.shares
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for backwards compatibility"""
        return self.model_dump()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Position':
        """Create from dictionary for backwards compatibility"""
        return cls(**data)


# Update TradingSignal to include trading execution details
def add_trading_execution_fields_to_signal():
    """Add missing fields to TradingSignal"""
    TradingSignal.model_fields.update({
        'entry_price': Optional[float], 
        'stop_loss': Optional[float],
        'profit_target': Optional[float], 
        'position_size': Optional[float],
        'shares': Optional[int]
    })


# Helper functions for backwards compatibility
def create_trading_signal(**kwargs) -> TradingSignal:
    """Create trading signal with backwards compatibility"""
    # Convert old field names if needed
    if 'action' in kwargs and isinstance(kwargs['action'], str):
        kwargs['action'] = TradingAction(kwargs['action'])
    
    return TradingSignal(**kwargs)


def create_position(**kwargs) -> Position:
    """Create position with backwards compatibility"""
    return Position(**kwargs)


def create_portfolio_summary(**kwargs) -> PortfolioSummary:
    """Create portfolio summary with backwards compatibility"""
    return PortfolioSummary(**kwargs)
